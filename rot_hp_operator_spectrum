#!/usr/bin/env python3
# rot_hp_operator_spectrum.py
# Numerical demo: eigenvalue spectrum of H = -i d/dx (unitarily equivalent to H_ROT = -i t d/dt)
# aligns with nontrivial zeta zeros via the prime-weighted spectral response
#   F(ω) = sum_{n<=N} Λ(n) n^{-1/2 - i ω}  ≈ -ζ'(1/2+iω)/ζ(1/2+iω).
#
# In ROT, set x = log t so that H_ROT = -i t d/dt maps to H = -i d/dx on L^2(R, dx).
# H is self-adjoint with plane-wave eigenfunctions e^{i ω x} and real eigenvalues ω.
# Evaluating F(ω) is equivalent to measuring the response of the prime-weighted
# "potential" against the eigenmodes e^{i ω x}. Zeros of ζ on σ=1/2 correspond to poles
# of ζ'/ζ, so |F(ω)| exhibits sharp features near those ω = γ (imag parts of zeros).
#
# This is NOT a formal proof of RH; it is a clean, constructive numerical demonstration
# of spectral alignment that matches the ROT operator picture.
#
# Usage examples:
#   python rot_hp_operator_spectrum.py --N 20000 --wmax 100 --dw 0.05 --topk 25 --out demo
#
# Outputs:
#   <out>_spectrum.csv  : ω, Re F, Im F, |F|
#   <out>_peaks.csv     : detected peaks (ω, |F|) near zeros
#   <out>_match.csv     : nearest-peak match to known zeros with errors
#   <out>_spectrum.png  : plot of |F(ω)| with true zero locations overlaid
#
import argparse
import numpy as np
import math
import csv
import sys
import time

try:
    import matplotlib.pyplot as plt
except Exception:
    plt = None

# First 20 imaginary parts of nontrivial zeta zeros (γ_n), high precision truncated
ZETA_GAMMAS_20 = [
    14.134725141734693790457251983562,
    21.022039638771554992628479593896,
    25.010857580145688763213790992562,
    30.424876125859513210311897530584,
    32.935061587739189690662368964074,
    37.586178158825671257217763480705,
    40.918719012147495187398126914633,
    43.327073280914999519496122165406,
    48.005150881167159727942472749427,
    49.773832477672302181916784678563,
    52.970321477714460644147296608880,
    56.446247697063394804367759476706,
    59.347044002602353079653648674993,
    60.831778524609809844259901824524,
    65.112544048081606660875054253183,
    67.079810529494173714478828896522,
    69.546401711173979252926857526554,
    72.067157674481907582522107969826,
    75.704690699083933168326916762050,
    77.144840068874805372682664856304,
]

def sieve_smallest_prime_factor(N):
    """Smallest prime factor (SPF) sieve up to N for O(1) factorization."""
    spf = np.zeros(N+1, dtype=np.int32)
    for i in range(2, N+1):
        if spf[i] == 0:
            spf[i] = i
            step = i
            start = i*i
            if start > N:
                continue
            for j in range(start, N+1, step):
                if spf[j] == 0:
                    spf[j] = i
    # fill remaining zeros (primes > sqrt(N))
    for i in range(2, N+1):
        if spf[i] == 0:
            spf[i] = i
    return spf

def von_mangoldt_all(N, spf=None):
    """Compute Λ(n) for 1..N. Λ(n)=log p if n=p^k (k>=1), else 0."""
    if spf is None:
        spf = sieve_smallest_prime_factor(N)
    lam = np.zeros(N+1, dtype=float)
    for n in range(2, N+1):
        p = spf[n]
        m = n // p
        # n is prime power iff m is 1 or divisible by p recursively down to 1
        is_power = True
        while m > 1:
            if spf[m] != p:
                is_power = False
                break
            m //= p
        if is_power:
            lam[n] = math.log(p)
    return lam

def fejer_window(N, n0=2):
    """Fejér-like taper from n0..N to reduce truncation artifacts; values in (0,1]."""
    idx = np.arange(n0, N+1, dtype=float)
    # map to [0, π]
    t = (idx - n0) / (N - n0)
    w = 1.0 - t  # triangular (Fejér) window
    return idx.astype(int), w

def compute_spectrum(N, wmax, dw, topk, out_prefix, gamma_list=ZETA_GAMMAS_20, chunk=512):
    t0 = time.time()
    # Precompute Λ(n)/sqrt(n) with a Fejér window
    spf = sieve_smallest_prime_factor(N)
    lam = von_mangoldt_all(N, spf)
    n_idx, w_fejer = fejer_window(N, n0=2)
    weights = np.zeros(N+1, dtype=float)
    weights[n_idx] = lam[n_idx] / np.sqrt(n_idx) * w_fejer
    # restrict to n where weight != 0
    n_support = np.nonzero(weights)[0]
    a = weights[n_support]
    x = np.log(n_support.astype(float))  # frequencies' spatial positions

    # ω grid
    omegas = np.arange(0.0, wmax + 1e-12, dw, dtype=float)
    F = np.zeros(omegas.shape, dtype=np.complex128)

    # Chunked NUFT: F(ω) = Σ a_k * e^{-i ω x_k}
    for i in range(0, len(omegas), chunk):
        block = omegas[i:i+chunk]
        # [block, n] complex exponentials
        M = np.exp(-1j * np.outer(block, x))
        F[i:i+chunk] = M @ a

    S = np.abs(F)

    # Peak detection (simple local maxima + threshold)
    # local maxima
    locs = []
    for i in range(1, len(S) - 1):
        if S[i] > S[i-1] and S[i] > S[i+1]:
            locs.append(i)
    locs = np.array(locs, dtype=int)
    if locs.size == 0:
        peak_omegas = np.array([])
        peak_vals = np.array([])
    else:
        # threshold by quantile to keep strongest peaks
        vals = S[locs]
        if locs.size > topk:
            idx = np.argsort(vals)[-topk:]
            locs = locs[idx]
            vals = vals[idx]
        # sort by omega ascending
        order = np.argsort(omegas[locs])
        locs = locs[order]
        vals = vals[order]
        peak_omegas = omegas[locs]
        peak_vals = vals

    # Match peaks to known zeros (nearest neighbor within window)
    matches = []
    for g in gamma_list:
        # consider only peaks within (0, wmax)
        candidates = peak_omegas[(peak_omegas >= 0.0) & (peak_omegas <= wmax)]
        if candidates.size == 0:
            matches.append((g, float('nan'), float('nan')))
            continue
        j = np.argmin(np.abs(candidates - g))
        matches.append((g, candidates[j], abs(candidates[j] - g)))

    # Write CSVs
    if out_prefix:
        with open(f"{out_prefix}_spectrum.csv", "w", newline="") as f:
            w = csv.writer(f)
            w.writerow(["omega", "ReF", "ImF", "absF"])
            for om, z in zip(omegas, F):
                w.writerow([f"{om:.12f}", f"{z.real:.12e}", f"{z.imag:.12e}", f"{abs(z):.12e}"])
        with open(f"{out_prefix}_peaks.csv", "w", newline="") as f:
            w = csv.writer(f)
            w.writerow(["omega_peak", "absF_peak"])
            for om, val in zip(peak_omegas, peak_vals):
                w.writerow([f"{om:.12f}", f"{val:.12e}"])
        with open(f"{out_prefix}_match.csv", "w", newline="") as f:
            w = csv.writer(f)
            w.writerow(["gamma_true", "omega_peak", "abs_error"])
            for g, om, err in matches:
                w.writerow([f"{g:.12f}", ("" if math.isnan(om) else f"{om:.12f}"), ("" if math.isnan(err) else f"{err:.12e}")])

    # Plot
    if plt is not None and out_prefix:
        fig = plt.figure(figsize=(10, 5))
        plt.plot(omegas, S, lw=1.0)
        # overlay zeros
        for g in gamma_list:
            if 0.0 <= g <= wmax:
                plt.axvline(g, linestyle="--", linewidth=0.8)
        plt.xlabel("ω (eigenvalue of H = -i d/dx)")
        plt.ylabel("|F(ω)| ≈ |-ζ'(1/2+iω) / ζ(1/2+iω)|")
        plt.title(f"Spectrum via prime-weighted response, N={N}, window=Fejér")
        plt.tight_layout()
        fig.savefig(f"{out_prefix}_spectrum.png", dpi=150)
        plt.close(fig)

    # Summary
    errs = [e for (_, _, e) in matches if not math.isnan(e)]
    mae = float(np.mean(errs)) if errs else float('nan')
    med = float(np.median(errs)) if errs else float('nan')
    mx = float(np.max(errs)) if errs else float('nan')
    dt = time.time() - t0
    return {
        "N": N,
        "wmax": wmax,
        "dw": dw,
        "topk": topk,
        "n_support": int(n_support.size),
        "n_omegas": int(omegas.size),
        "n_peaks": int(peak_omegas.size),
        "match_mae": mae,
        "match_median": med,
        "match_max": mx,
        "seconds": dt,
        "out_prefix": out_prefix,
    }

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--N", type=int, default=15000, help="Dirichlet cutoff for Λ(n)")
    ap.add_argument("--wmax", type=float, default=100.0, help="max ω to scan")
    ap.add_argument("--dw", type=float, default=0.05, help="ω grid step")
    ap.add_argument("--topk", type=int, default=60, help="number of peaks to keep")
    ap.add_argument("--out", type=str, default="rot_hp_demo", help="output prefix (files)")
    args = ap.parse_args()

    res = compute_spectrum(
        N=args.N, wmax=args.wmax, dw=args.dw, topk=args.topk, out_prefix=args.out
    )
    print("[done]",
          f"N={res['N']}, support={res['n_support']}, omegas={res['n_omegas']}, peaks={res['n_peaks']}")
    print("[match]",
          f"MAE={res['match_mae']:.4f}, median={res['match_median']:.4f}, max={res['match_max']:.4f}")
    print("[time]", f"{res['seconds']:.2f}s, out_prefix={res['out_prefix']}")

if __name__ == "__main__":
    main()
